struct Example(i32);

impl Drop for Example {
    fn drop(&mut self) {
        println!("{}", self.0);
    }
}

struct ExampleWrap(Example);

impl Drop for ExampleWrap {
    fn drop(&mut self) {
        let e = std::mem::replace(&mut self.0, Example(0)); // Текущему экземпляру структуры присваивается значение Example(0), переменной "е" присваивается предыдущее значение экземпляра структуры (в данном случае Example(8)),
        println!("wrap {}", e.0); // Вывод предыдущего значения

        // По окончании данного участка вызываются деструкторы для значений хранящихся в стеке по принципу - последним вошел первым вышел
    }
}

fn main() {
    Example(1); // Содается экземпляр структуры Example со значением "1", т.к. данное значение не передается во владение - временное значение "1" удаляется по окончании иструкции
    let _e2 = Example(2);
    let _e3 = Example(3);
    let _ = Example(4); // Поскольку "_" не перемещает значение, экземпляр Example(4) созданный на данной инструкции будет удален по ее окончании
    let mut _e5;
    _e5 = Some(Example(5)); // Создается экземпляр Example(5) и передается во владение переменной _е5
    _e5 = None; // Переменной _е5 присваивается значение None, значение Example(5) выходит из области видимости и удаляется
    let e6 = Example(6);
    drop(e6); // Метод drop вызывается явно для значения Example(6)
    let e7 = Example(7);
    std::mem::forget(e7); // Пространство занимаемое переменной e7 освобождается без вызова деструктора, вследствие чего значение не будет отображено в выводе
    ExampleWrap(Example(8)); // Создается экземпляр структуры ExampleWrap со значением Example(8), после чего будет вызван деструктор данной структуры

    // По окончании данного участка вызываются деструкторы для значений хранящихся в стеке по принципу - последним вошел первым вышел, уничтожаются переменные "_e3" и "_e2"
}
